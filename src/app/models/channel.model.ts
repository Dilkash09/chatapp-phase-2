export interface Channel {
  // MongoDB properties
  _id?: string;
  // Legacy properties
  id?: string;
  
  // Core properties
  name: string;
  groupId: string;
  createdBy: string;
  
  // Additional properties
  description?: string;
  bannedUsers?: string[];
  
  // Metadata
  createdAt?: Date;
  updatedAt?: Date;
}

export class ChannelModel implements Channel {
  constructor(
    // MongoDB ID
    public _id?: string,
    // Legacy ID
    public id?: string,
    
    // Core properties
    public name: string = '',
    public groupId: string = '',
    public createdBy: string = '',
    
    // Additional properties
    public description: string = '',
    public bannedUsers: string[] = [],
    
    // Metadata
    public createdAt?: Date,
    public updatedAt?: Date
  ) {}

  // Get the primary ID (prefer MongoDB _id, fallback to legacy id)
  get primaryId(): string {
    return this._id || this.id || '';
  }

  // Check if user is banned from this channel
  isUserBanned(userId: string): boolean {
    return this.bannedUsers.includes(userId);
  }

  // Ban a user from this channel
  banUser(userId: string): void {
    if (!this.isUserBanned(userId)) {
      this.bannedUsers.push(userId);
      this.updatedAt = new Date();
    }
  }

  // Unban a user from this channel
  unbanUser(userId: string): void {
    const index = this.bannedUsers.indexOf(userId);
    if (index > -1) {
      this.bannedUsers.splice(index, 1);
      this.updatedAt = new Date();
    }
  }

  // Convert to JSON for API calls
  toJSON(): any {
    return {
      // Prefer MongoDB _id for new data
      ...(this._id && { _id: this._id }),
      ...(this.id && { id: this.id }),
      
      name: this.name,
      groupId: this.groupId,
      createdBy: this.createdBy,
      
      ...(this.description && { description: this.description }),
      ...(this.bannedUsers.length > 0 && { bannedUsers: this.bannedUsers }),
      
      ...(this.createdAt && { createdAt: this.createdAt }),
      ...(this.updatedAt && { updatedAt: this.updatedAt })
    };
  }

  // Create from JSON with support for both MongoDB and legacy data
  static fromJSON(json: any): ChannelModel {
    return new ChannelModel(
      json._id, // MongoDB ID
      json.id, // Legacy ID
      json.name,
      json.groupId,
      json.createdBy,
      json.description || '',
      json.bannedUsers || [],
      json.createdAt ? new Date(json.createdAt) : undefined,
      json.updatedAt ? new Date(json.updatedAt) : undefined
    );
  }

  // Create a new channel for API calls
  static createChannel(
    name: string,
    groupId: string,
    createdBy: string,
    description: string = ''
  ): ChannelModel {
    return new ChannelModel(
      undefined, // _id will be generated by MongoDB
      undefined, // id will be generated if needed
      name,
      groupId,
      createdBy,
      description,
      [], // empty banned users
      new Date(), // createdAt
      new Date()  // updatedAt
    );
  }

  // Create from socket data (real-time updates)
  static fromSocketData(data: any): ChannelModel {
    return ChannelModel.fromJSON({
      _id: data._id,
      id: data.id,
      name: data.name,
      groupId: data.groupId,
      createdBy: data.createdBy,
      description: data.description,
      bannedUsers: data.bannedUsers,
      createdAt: data.createdAt,
      updatedAt: data.updatedAt
    });
  }

  // Update channel properties
  updateProperties(updates: Partial<Channel>): void {
    Object.assign(this, updates);
    this.updatedAt = new Date();
  }

  // Check if user can modify this channel
  canUserModify(userId: string, userRoles: string[] = []): boolean {
    return this.createdBy === userId || 
           userRoles.includes('super_admin') || 
           userRoles.includes('group_admin');
  }

  // Get display name with group context
  getDisplayName(): string {
    return `#${this.name}`;
  }
}