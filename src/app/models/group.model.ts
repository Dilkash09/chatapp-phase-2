export interface Group {
  // MongoDB properties
  _id?: string;
  // Legacy properties
  id?: string;
  
  // Core properties
  name: string;
  description: string;
  createdBy: string;
  
  // Members and admins
  members: string[];
  admins: string[];
  channels: string[];
  
  // Metadata
  createdAt?: Date;
  updatedAt?: Date;
}

export class GroupModel implements Group {
  constructor(
    // MongoDB ID
    public _id?: string,
    // Legacy ID
    public id?: string,
    
    // Core properties
    public name: string = '',
    public description: string = '',
    public createdBy: string = '',
    
    // Members and admins
    public members: string[] = [],
    public admins: string[] = [],
    public channels: string[] = [],
    
    // Metadata
    public createdAt?: Date,
    public updatedAt?: Date
  ) {}

  // Get the primary ID (prefer MongoDB _id, fallback to legacy id)
  get primaryId(): string {
    return this._id || this.id || '';
  }

  // Member management
  isMember(userId: string): boolean {
    return this.members.includes(userId) || this.admins.includes(userId) || this.createdBy === userId;
  }

  isAdmin(userId: string): boolean {
    return this.admins.includes(userId) || this.createdBy === userId;
  }

  addMember(userId: string): void {
    if (!this.isMember(userId)) {
      this.members.push(userId);
      this.updatedAt = new Date();
    }
  }

  removeMember(userId: string): void {
    const memberIndex = this.members.indexOf(userId);
    if (memberIndex > -1) {
      this.members.splice(memberIndex, 1);
      this.updatedAt = new Date();
    }
  }

  promoteToAdmin(userId: string): void {
    if (this.isMember(userId) && !this.isAdmin(userId)) {
      this.removeMember(userId);
      this.admins.push(userId);
      this.updatedAt = new Date();
    }
  }

  demoteFromAdmin(userId: string): void {
    const adminIndex = this.admins.indexOf(userId);
    if (adminIndex > -1 && userId !== this.createdBy) {
      this.admins.splice(adminIndex, 1);
      this.members.push(userId);
      this.updatedAt = new Date();
    }
  }

  // Channel management
  addChannel(channelId: string): void {
    if (!this.channels.includes(channelId)) {
      this.channels.push(channelId);
      this.updatedAt = new Date();
    }
  }

  removeChannel(channelId: string): void {
    const channelIndex = this.channels.indexOf(channelId);
    if (channelIndex > -1) {
      this.channels.splice(channelIndex, 1);
      this.updatedAt = new Date();
    }
  }

  // Convert to JSON for API calls
  toJSON(): any {
    return {
      // Prefer MongoDB _id for new data
      ...(this._id && { _id: this._id }),
      ...(this.id && { id: this.id }),
      
      name: this.name,
      description: this.description,
      createdBy: this.createdBy,
      
      members: this.members,
      admins: this.admins,
      channels: this.channels,
      
      ...(this.createdAt && { createdAt: this.createdAt }),
      ...(this.updatedAt && { updatedAt: this.updatedAt })
    };
  }

  // Create from JSON with support for both MongoDB and legacy data
  static fromJSON(json: any): GroupModel {
    return new GroupModel(
      json._id, // MongoDB ID
      json.id, // Legacy ID
      json.name,
      json.description,
      json.createdBy,
      json.members || [],
      json.admins || [],
      json.channels || [],
      json.createdAt ? new Date(json.createdAt) : undefined,
      json.updatedAt ? new Date(json.updatedAt) : undefined
    );
  }

  // Create a new group for API calls
  static createGroup(
    name: string,
    description: string,
    createdBy: string
  ): GroupModel {
    return new GroupModel(
      undefined, // _id will be generated by MongoDB
      undefined, // id will be generated if needed
      name,
      description,
      createdBy,
      [createdBy], // creator is automatically a member
      [createdBy], // creator is automatically an admin
      [], // empty channels
      new Date(), // createdAt
      new Date()  // updatedAt
    );
  }

  // Create from socket data (real-time updates)
  static fromSocketData(data: any): GroupModel {
    return GroupModel.fromJSON({
      _id: data._id,
      id: data.id,
      name: data.name,
      description: data.description,
      createdBy: data.createdBy,
      members: data.members,
      admins: data.admins,
      channels: data.channels,
      createdAt: data.createdAt,
      updatedAt: data.updatedAt
    });
  }

  // Update group properties
  updateProperties(updates: Partial<Group>): void {
    Object.assign(this, updates);
    this.updatedAt = new Date();
  }

  // Check if user can manage this group
  canUserManage(userId: string, userRoles: string[] = []): boolean {
    return this.createdBy === userId || 
           userRoles.includes('super_admin') || 
           this.admins.includes(userId);
  }

  // Check if user can modify this group (more restrictive than manage)
  canUserModify(userId: string, userRoles: string[] = []): boolean {
    return this.createdBy === userId || 
           userRoles.includes('super_admin');
  }

  // Get member count including admins and creator
  getMemberCount(): number {
    const allMembers = new Set([...this.members, ...this.admins, this.createdBy]);
    return allMembers.size;
  }

  // Get all member IDs including admins and creator
  getAllMemberIds(): string[] {
    const allMembers = new Set([...this.members, ...this.admins, this.createdBy]);
    return Array.from(allMembers);
  }

  // Get display name with member count
  getDisplayName(): string {
    return `${this.name} (${this.getMemberCount()} members)`;
  }

  // Check if group has channels
  hasChannels(): boolean {
    return this.channels.length > 0;
  }

  // Get channel count
  getChannelCount(): number {
    return this.channels.length;
  }
}